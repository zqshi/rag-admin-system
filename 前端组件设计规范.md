# RAG系统前端组件设计规范

**版本**: 1.0  
**团队**: Frontend Team  
**日期**: 2025年8月12日

---

## 一、组件架构

### 1.1 技术栈
```json
{
  "framework": "React 18.2",
  "language": "TypeScript 5.0",
  "ui": "Ant Design 5.0",
  "state": "Zustand 4.0",
  "styling": "CSS Modules + Tailwind",
  "build": "Vite 4.0",
  "test": "Vitest + React Testing Library"
}
```

### 1.2 目录结构
```
src/
├── components/           # 通用组件
│   ├── base/            # 基础组件
│   ├── business/        # 业务组件
│   └── layout/          # 布局组件
├── features/            # 功能模块
│   ├── knowledge/       # 知识管理
│   ├── search/          # 搜索配置
│   └── strategy/        # 策略中心
├── hooks/               # 自定义Hooks
├── utils/               # 工具函数
├── styles/              # 全局样式
└── types/               # TypeScript类型
```

---

## 二、核心业务组件

### 2.1 DocumentUploader（文档上传器）

```typescript
interface DocumentUploaderProps {
  multiple?: boolean;
  maxSize?: number; // MB
  accept?: string[];
  onUpload: (files: File[]) => Promise<void>;
  onProgress?: (progress: UploadProgress) => void;
}

const DocumentUploader: React.FC<DocumentUploaderProps> = ({
  multiple = true,
  maxSize = 100,
  accept = ['.pdf', '.docx', '.xlsx', '.txt', '.md'],
  onUpload,
  onProgress
}) => {
  const [uploading, setUploading] = useState(false);
  const [fileList, setFileList] = useState<UploadFile[]>([]);
  
  const uploadProps: UploadProps = {
    name: 'file',
    multiple,
    accept: accept.join(','),
    fileList,
    customRequest: async ({ file, onProgress, onSuccess, onError }) => {
      const formData = new FormData();
      formData.append('file', file as File);
      
      try {
        const response = await uploadDocument(formData, {
          onUploadProgress: (progressEvent) => {
            const percentCompleted = Math.round(
              (progressEvent.loaded * 100) / progressEvent.total
            );
            onProgress?.({ percent: percentCompleted });
          }
        });
        onSuccess?.(response.data);
      } catch (error) {
        onError?.(error);
      }
    },
    beforeUpload: (file) => {
      const isValidType = accept.some(ext => 
        file.name.toLowerCase().endsWith(ext)
      );
      const isValidSize = file.size / 1024 / 1024 < maxSize;
      
      if (!isValidType) {
        message.error(`文件格式不支持`);
        return false;
      }
      if (!isValidSize) {
        message.error(`文件大小不能超过${maxSize}MB`);
        return false;
      }
      return true;
    }
  };
  
  return (
    <div className="document-uploader">
      <Dragger {...uploadProps}>
        <p className="ant-upload-drag-icon">
          <InboxOutlined />
        </p>
        <p className="ant-upload-text">
          拖拽文件到此处或点击选择
        </p>
        <p className="ant-upload-hint">
          支持格式: {accept.join(', ')} | 最大: {maxSize}MB
        </p>
      </Dragger>
      
      {/* 上传队列 */}
      {fileList.length > 0 && (
        <UploadQueue 
          files={fileList}
          onRetry={handleRetry}
          onCancel={handleCancel}
        />
      )}
    </div>
  );
};
```

### 2.2 ChunkEditor（片段编辑器）

```typescript
interface ChunkEditorProps {
  documentId: string;
  chunks: Chunk[];
  onSave: (chunks: Chunk[]) => Promise<void>;
  readOnly?: boolean;
}

const ChunkEditor: React.FC<ChunkEditorProps> = ({
  documentId,
  chunks: initialChunks,
  onSave,
  readOnly = false
}) => {
  const [chunks, setChunks] = useState(initialChunks);
  const [selectedChunk, setSelectedChunk] = useState<Chunk | null>(null);
  const [editMode, setEditMode] = useState<'view' | 'edit' | 'merge'>('view');
  
  // 虚拟滚动优化
  const rowVirtualizer = useVirtualizer({
    count: chunks.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 120,
    overscan: 5
  });
  
  const handleMergeChunks = (chunkIds: string[]) => {
    const chunksToMerge = chunks.filter(c => chunkIds.includes(c.id));
    const mergedContent = chunksToMerge.map(c => c.content).join('\n');
    
    const mergedChunk: Chunk = {
      id: generateId(),
      content: mergedContent,
      tokens: calculateTokens(mergedContent),
      position: chunksToMerge[0].position,
      quality: calculateQuality(mergedContent)
    };
    
    setChunks(prev => {
      const filtered = prev.filter(c => !chunkIds.includes(c.id));
      return [...filtered, mergedChunk].sort((a, b) => a.position - b.position);
    });
  };
  
  return (
    <div className="chunk-editor">
      <div className="chunk-editor-toolbar">
        <Space>
          <Button
            icon={<ScissorOutlined />}
            onClick={() => setEditMode('edit')}
            disabled={!selectedChunk}
          >
            拆分
          </Button>
          <Button
            icon={<LinkOutlined />}
            onClick={() => setEditMode('merge')}
            disabled={!selectedChunk}
          >
            合并
          </Button>
          <Button
            type="primary"
            icon={<SaveOutlined />}
            onClick={() => onSave(chunks)}
            loading={saving}
          >
            保存
          </Button>
        </Space>
      </div>
      
      <div className="chunk-editor-content">
        <Row gutter={16}>
          <Col span={8}>
            <ChunkList
              chunks={chunks}
              selectedId={selectedChunk?.id}
              onSelect={setSelectedChunk}
              virtualizer={rowVirtualizer}
            />
          </Col>
          <Col span={16}>
            {selectedChunk && (
              <ChunkDetail
                chunk={selectedChunk}
                mode={editMode}
                onChange={handleChunkChange}
                onMerge={handleMergeChunks}
              />
            )}
          </Col>
        </Row>
      </div>
    </div>
  );
};
```

### 2.3 StrategyBuilder（策略构建器）

```typescript
interface StrategyBuilderProps {
  strategy?: Strategy;
  onSave: (strategy: Strategy) => Promise<void>;
  onTest?: (strategy: Strategy) => Promise<TestResult>;
}

const StrategyBuilder: React.FC<StrategyBuilderProps> = ({
  strategy: initialStrategy,
  onSave,
  onTest
}) => {
  const [strategy, setStrategy] = useState<Strategy>(
    initialStrategy || getDefaultStrategy()
  );
  const [testResult, setTestResult] = useState<TestResult | null>(null);
  
  // 策略节点拖拽
  const [nodes, setNodes, onNodesChange] = useNodesState(
    strategyToNodes(strategy)
  );
  const [edges, setEdges, onEdgesChange] = useEdgesState(
    strategyToEdges(strategy)
  );
  
  const onConnect = useCallback((params) => {
    setEdges((eds) => addEdge(params, eds));
  }, []);
  
  const handleNodeDrop = (event: DragEvent, position: XYPosition) => {
    const type = event.dataTransfer?.getData('nodeType');
    if (!type) return;
    
    const newNode = {
      id: generateId(),
      type,
      position,
      data: getNodeDefaultData(type)
    };
    
    setNodes((nds) => nds.concat(newNode));
  };
  
  return (
    <div className="strategy-builder">
      <Row gutter={16}>
        <Col span={4}>
          <NodePalette />
        </Col>
        <Col span={14}>
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onDrop={handleNodeDrop}
            fitView
          >
            <Controls />
            <MiniMap />
            <Background variant="dots" gap={12} size={1} />
          </ReactFlow>
        </Col>
        <Col span={6}>
          <StrategyConfig
            strategy={strategy}
            onChange={setStrategy}
          />
          
          <Space direction="vertical" style={{ width: '100%' }}>
            <Button
              block
              icon={<PlayCircleOutlined />}
              onClick={async () => {
                const result = await onTest?.(strategy);
                setTestResult(result);
              }}
            >
              测试策略
            </Button>
            
            <Button
              block
              type="primary"
              icon={<SaveOutlined />}
              onClick={() => onSave(strategy)}
            >
              保存策略
            </Button>
          </Space>
          
          {testResult && (
            <TestResultPanel result={testResult} />
          )}
        </Col>
      </Row>
    </div>
  );
};
```

### 2.4 VectorVisualizer（向量可视化）

```typescript
interface VectorVisualizerProps {
  vectors: Vector[];
  dimension: number;
  colorBy?: 'cluster' | 'quality' | 'source';
  interactive?: boolean;
}

const VectorVisualizer: React.FC<VectorVisualizerProps> = ({
  vectors,
  dimension,
  colorBy = 'cluster',
  interactive = true
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [selectedVector, setSelectedVector] = useState<Vector | null>(null);
  
  useEffect(() => {
    if (!containerRef.current) return;
    
    // t-SNE降维可视化
    const tsne = new TSNE({
      dim: 2,
      perplexity: 30,
      earlyExaggeration: 4.0,
      learningRate: 100,
      nIter: 1000
    });
    
    const coordinates = tsne.fit(vectors.map(v => v.embedding));
    
    // D3.js绘制
    const svg = d3.select(containerRef.current)
      .append('svg')
      .attr('width', '100%')
      .attr('height', 500);
    
    const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
    
    const circles = svg.selectAll('circle')
      .data(vectors)
      .enter()
      .append('circle')
      .attr('cx', (d, i) => coordinates[i][0] * 200 + 250)
      .attr('cy', (d, i) => coordinates[i][1] * 200 + 250)
      .attr('r', 5)
      .attr('fill', d => colorScale(d[colorBy]))
      .attr('opacity', 0.7);
    
    if (interactive) {
      circles
        .on('mouseover', function(event, d) {
          d3.select(this)
            .transition()
            .duration(200)
            .attr('r', 8);
          
          setSelectedVector(d);
        })
        .on('mouseout', function() {
          d3.select(this)
            .transition()
            .duration(200)
            .attr('r', 5);
        });
    }
    
    return () => {
      d3.select(containerRef.current).selectAll('*').remove();
    };
  }, [vectors, colorBy]);
  
  return (
    <div className="vector-visualizer">
      <div ref={containerRef} />
      {selectedVector && (
        <VectorDetail vector={selectedVector} />
      )}
    </div>
  );
};
```

---

## 三、通用Hooks

### 3.1 useDebounce

```typescript
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}
```

### 3.2 useInfiniteScroll

```typescript
function useInfiniteScroll<T>({
  queryFn,
  getNextPageParam,
  enabled = true
}: InfiniteScrollOptions<T>) {
  const observerTarget = useRef<HTMLDivElement>(null);
  
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  } = useInfiniteQuery({
    queryKey: ['infinite-scroll'],
    queryFn,
    getNextPageParam,
    enabled
  });
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      entries => {
        if (entries[0].isIntersecting && hasNextPage) {
          fetchNextPage();
        }
      },
      { threshold: 0.1 }
    );
    
    if (observerTarget.current) {
      observer.observe(observerTarget.current);
    }
    
    return () => observer.disconnect();
  }, [hasNextPage, fetchNextPage]);
  
  return {
    data: data?.pages.flatMap(page => page.items) ?? [],
    observerTarget,
    isFetchingNextPage,
    hasNextPage
  };
}
```

### 3.3 useWebSocket

```typescript
function useWebSocket(url: string, options?: WebSocketOptions) {
  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [lastMessage, setLastMessage] = useState<any>(null);
  const [readyState, setReadyState] = useState<number>(
    WebSocket.CONNECTING
  );
  
  useEffect(() => {
    const ws = new WebSocket(url);
    
    ws.onopen = () => {
      setReadyState(WebSocket.OPEN);
      options?.onOpen?.();
    };
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setLastMessage(data);
      options?.onMessage?.(data);
    };
    
    ws.onerror = (error) => {
      options?.onError?.(error);
    };
    
    ws.onclose = () => {
      setReadyState(WebSocket.CLOSED);
      options?.onClose?.();
      
      // 自动重连
      if (options?.reconnect) {
        setTimeout(() => {
          setSocket(new WebSocket(url));
        }, options.reconnectDelay || 3000);
      }
    };
    
    setSocket(ws);
    
    return () => {
      ws.close();
    };
  }, [url]);
  
  const sendMessage = useCallback((message: any) => {
    if (socket?.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(message));
    }
  }, [socket]);
  
  return {
    socket,
    sendMessage,
    lastMessage,
    readyState
  };
}
```

---

## 四、状态管理

### 4.1 Store设计

```typescript
// stores/documentStore.ts
interface DocumentStore {
  documents: Document[];
  loading: boolean;
  error: Error | null;
  filters: DocumentFilters;
  
  // Actions
  fetchDocuments: () => Promise<void>;
  uploadDocument: (file: File) => Promise<void>;
  deleteDocument: (id: string) => Promise<void>;
  updateFilters: (filters: Partial<DocumentFilters>) => void;
  
  // Computed
  filteredDocuments: Document[];
  totalCount: number;
}

const useDocumentStore = create<DocumentStore>((set, get) => ({
  documents: [],
  loading: false,
  error: null,
  filters: {
    status: 'all',
    type: 'all',
    search: ''
  },
  
  fetchDocuments: async () => {
    set({ loading: true, error: null });
    try {
      const response = await api.getDocuments(get().filters);
      set({ documents: response.data, loading: false });
    } catch (error) {
      set({ error, loading: false });
    }
  },
  
  uploadDocument: async (file) => {
    const formData = new FormData();
    formData.append('file', file);
    
    try {
      const response = await api.uploadDocument(formData);
      set(state => ({
        documents: [...state.documents, response.data]
      }));
      
      message.success('文档上传成功');
    } catch (error) {
      message.error('上传失败');
      throw error;
    }
  },
  
  deleteDocument: async (id) => {
    try {
      await api.deleteDocument(id);
      set(state => ({
        documents: state.documents.filter(d => d.id !== id)
      }));
      
      message.success('删除成功');
    } catch (error) {
      message.error('删除失败');
      throw error;
    }
  },
  
  updateFilters: (filters) => {
    set(state => ({
      filters: { ...state.filters, ...filters }
    }));
  },
  
  get filteredDocuments() {
    const { documents, filters } = get();
    return documents.filter(doc => {
      if (filters.status !== 'all' && doc.status !== filters.status) {
        return false;
      }
      if (filters.type !== 'all' && doc.type !== filters.type) {
        return false;
      }
      if (filters.search && !doc.name.includes(filters.search)) {
        return false;
      }
      return true;
    });
  },
  
  get totalCount() {
    return get().documents.length;
  }
}));
```

---

## 五、性能优化规范

### 5.1 代码分割

```typescript
// 路由级别分割
const KnowledgeModule = lazy(() => 
  import(/* webpackChunkName: "knowledge" */ './features/knowledge')
);

// 组件级别分割
const HeavyComponent = lazy(() =>
  import(/* webpackChunkName: "heavy" */ './components/HeavyComponent')
);

// 条件加载
const loadChart = async () => {
  const { Chart } = await import('chart.js');
  return Chart;
};
```

### 5.2 渲染优化

```typescript
// 1. Memo优化
const ExpensiveComponent = memo(({ data }) => {
  return <ComplexVisualization data={data} />;
}, (prevProps, nextProps) => {
  return prevProps.data.id === nextProps.data.id;
});

// 2. useMemo优化
const MemoizedList = ({ items, filter }) => {
  const filteredItems = useMemo(
    () => items.filter(item => item.name.includes(filter)),
    [items, filter]
  );
  
  return <List items={filteredItems} />;
};

// 3. useCallback优化
const SearchInput = ({ onSearch }) => {
  const handleSearch = useCallback(
    debounce((value: string) => {
      onSearch(value);
    }, 300),
    [onSearch]
  );
  
  return <Input onChange={e => handleSearch(e.target.value)} />;
};
```

---

## 六、测试规范

### 6.1 组件测试

```typescript
describe('DocumentUploader', () => {
  it('should upload file successfully', async () => {
    const onUpload = vi.fn();
    const { getByText } = render(
      <DocumentUploader onUpload={onUpload} />
    );
    
    const file = new File(['content'], 'test.pdf', {
      type: 'application/pdf'
    });
    
    const input = document.querySelector('input[type="file"]');
    await userEvent.upload(input, file);
    
    await waitFor(() => {
      expect(onUpload).toHaveBeenCalledWith([file]);
    });
  });
  
  it('should reject invalid file type', async () => {
    const { getByText } = render(<DocumentUploader />);
    
    const file = new File(['content'], 'test.exe');
    const input = document.querySelector('input[type="file"]');
    
    await userEvent.upload(input, file);
    
    expect(getByText('文件格式不支持')).toBeInTheDocument();
  });
});
```

### 6.2 Hook测试

```typescript
describe('useDebounce', () => {
  it('should debounce value changes', async () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      {
        initialProps: { value: 'initial', delay: 500 }
      }
    );
    
    expect(result.current).toBe('initial');
    
    rerender({ value: 'updated', delay: 500 });
    expect(result.current).toBe('initial');
    
    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 600));
    });
    
    expect(result.current).toBe('updated');
  });
});
```

---

## 七、无障碍规范

### 7.1 ARIA标签

```typescript
const AccessibleButton: React.FC<ButtonProps> = ({
  children,
  loading,
  disabled,
  onClick,
  ...props
}) => {
  return (
    <button
      aria-busy={loading}
      aria-disabled={disabled}
      aria-label={props['aria-label'] || children?.toString()}
      onClick={disabled ? undefined : onClick}
      {...props}
    >
      {loading && <span className="sr-only">加载中...</span>}
      {children}
    </button>
  );
};
```

### 7.2 键盘导航

```typescript
const KeyboardNavigableList: React.FC<ListProps> = ({ items }) => {
  const [focusedIndex, setFocusedIndex] = useState(0);
  
  const handleKeyDown = (e: KeyboardEvent) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setFocusedIndex(prev => 
          Math.min(prev + 1, items.length - 1)
        );
        break;
      case 'ArrowUp':
        e.preventDefault();
        setFocusedIndex(prev => Math.max(prev - 1, 0));
        break;
      case 'Enter':
        items[focusedIndex]?.onClick?.();
        break;
    }
  };
  
  return (
    <ul role="listbox" onKeyDown={handleKeyDown}>
      {items.map((item, index) => (
        <li
          key={item.id}
          role="option"
          tabIndex={focusedIndex === index ? 0 : -1}
          aria-selected={focusedIndex === index}
        >
          {item.label}
        </li>
      ))}
    </ul>
  );
};
```

---

## 八、错误边界

```typescript
class ErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  state = {
    hasError: false,
    error: null
  };
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // 上报错误
    reportError({
      error: error.toString(),
      errorInfo: errorInfo.componentStack,
      timestamp: Date.now(),
      userAgent: navigator.userAgent
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <Result
          status="500"
          title="页面出错了"
          subTitle={this.state.error?.message}
          extra={
            <Button onClick={() => window.location.reload()}>
              刷新页面
            </Button>
          }
        />
      );
    }
    
    return this.props.children;
  }
}
```

---

## 九、国际化

```typescript
// i18n/locales/zh-CN.ts
export default {
  common: {
    save: '保存',
    cancel: '取消',
    delete: '删除',
    confirm: '确认',
    loading: '加载中...'
  },
  document: {
    upload: '上传文档',
    uploadSuccess: '上传成功',
    uploadFailed: '上传失败',
    deleteConfirm: '确认删除此文档？'
  }
};

// 使用
const DocumentPage = () => {
  const { t } = useTranslation();
  
  return (
    <Button onClick={handleUpload}>
      {t('document.upload')}
    </Button>
  );
};
```

---

## 十、开发工具链

### 10.1 ESLint配置

```json
{
  "extends": [
    "react-app",
    "plugin:@typescript-eslint/recommended",
    "plugin:react-hooks/recommended",
    "plugin:jsx-a11y/recommended"
  ],
  "rules": {
    "react-hooks/exhaustive-deps": "warn",
    "no-console": ["warn", { "allow": ["warn", "error"] }],
    "@typescript-eslint/no-unused-vars": ["error", {
      "argsIgnorePattern": "^_"
    }]
  }
}
```

### 10.2 Git提交规范

```bash
# 提交格式
<type>(<scope>): <subject>

# 示例
feat(upload): 添加批量上传功能
fix(chunk): 修复片段合并错误
perf(list): 优化长列表渲染性能
docs(readme): 更新组件使用文档

# 类型说明
feat: 新功能
fix: 修复bug
perf: 性能优化
style: 代码格式
refactor: 重构
test: 测试
docs: 文档
chore: 构建/工具
```

---

## 更新日志

| 版本 | 日期 | 更新内容 |
|------|------|----------|
| 1.0 | 2025-08-12 | 初始规范发布 |